# Golang变量注意点

## 变量类型分类

- 值类型
    - int
    - float
    - string
    - bool
    - array
    - struct

- 引用类型
    - slice
    - map
    - channel
    - pointer

## 变量类型在内存中存储分类

- 值类型
    - 存储在内存中的【**栈**】中。
- 引用类型
    - 存储在内存中的【**堆**】中，以便进行垃圾回收，且比栈拥有更大的内存空间。

## 变量赋值

- 值类型：
    - `var a = 3`
    - `var b = a`
    - 变量的赋值将发生***内存拷贝***，修改变量`a`的值不会影响变量`b`的值，因为它们在内存中占用两个不同的内存块。
- 引用类型：
    - `var a int = 3`
    - `var b = &a`
    - 变量的赋值将发生***指针(地址)拷贝***，修改变量`a`的值会影响变量`b`的值，因为它们的指针，指向的是同一地址。
    
## 变量的作用域

- 全局变量
    - 声明可以不使用，也就是说，声明了不使用它，编译器也不会编译错误，**_但是不提倡这么做_**。
- 局部变量
    - 声明不可以不使用，也就是说，声明了你就必须要使用它，这正是遵循了 Go 的格言："**_没有不必要的代码！_**"
    
## 推断以下程序的输出，并解释你的答案

### No.Scene.1

```go
package main

var a = "G"

func main() {
    n()
    m()
    n()
}

func n() { 
    print(a) 
}

func m() {
    a := "O"
    print(a)
}
```

_**程序执行过程分析如下：**_

程序输出结果为`G0G`，当第一次调用n函数时，输出全局变量a的值G，当调用m函数时，因为在函数内部声明了一个局部变量a，此时外部的全局变量a被暂时覆盖，所以输出0，当第二次调用n函数时，被覆盖的全局变量a再次启用，所以输出为全局变量a的值G。

### No.Scene.2

```go
package main

var a = "G"

func main() {
    n()
    m()
    n()
}

func n() {
    print(a)
}

func m() {
    a = "O"
    print(a)
}
```

_**程序执行过程分析如下：**_

程序输出结果为`G00`，当第一次调用n函数时，输出全局变量a的值G，当调用m函数时，因为在函数内部重新对全局变量a赋值为0，所以输出0，当第二次调用n函数时，上次调用m函数时，由于全局变量a被重新赋值，所以输出为全局变量a的新值0。

### No.Scene.3

```go
package main

var a string

func main() {
    a = "G"
    print(a)
    f1()
}

func f1() {
    a := "O"
    print(a)
    f2()
}

func f2() {
    print(a)
}
```

_**程序执行过程分析如下：**_

程序输出结果为`G0G`，在main函数中全局变量a被赋值为G，所以输出为G，在main函数中，调用f1函数时，在函数f1内部，声明了一个局部变量a，并赋值为0，所以输出为0，在f1函数中，调用f2函数，由于全局变量a在main函数中被赋值为G，所以f2函数会输出G,而不是0，虽然f2函数是在f1函数内调用，但是它访问的依旧是全局变量 a,而不是你f1函数的局部变量a

## 目录
[Back](../../README.md)


